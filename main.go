package main

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"
	"unsafe"
	"strconv"
	"strings"
	"flag"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// SymbolProbe defines a symbol to probe in the target binary.
type SymbolProbe struct {
	Name          string
	UprobeProgram string
	UprobeExProgram string
}

// findKubeAPIServer detects if running in a DaemonSet (with /host/proc) and locates the kube-apiserver process.
// It returns the PID, executable path, whether the target is in a container, and an error if any.
func findKubeAPIServer() (pid int, exePath string, inContainer bool, err error) {
	procBase := "/proc"
	if _, err := os.Stat("/host/proc"); err == nil {
		// We're running in a DaemonSet with /host/proc mounted
		procBase = "/host/proc"
	}

	procDir, err := os.ReadDir(procBase)
	if err != nil {
		return 0, "", false, fmt.Errorf("reading %s: %w", procBase, err)
	}

	for _, entry := range procDir {
		if !entry.IsDir() {
			continue
		}
		pidStr := entry.Name()
		if _, err := strconv.Atoi(pidStr); err != nil {
			continue
		}

		cmdlinePath := fmt.Sprintf("%s/%s/cmdline", procBase, pidStr)
		cmdline, err := os.ReadFile(cmdlinePath)
		if err != nil || !bytes.Contains(cmdline, []byte("kube-apiserver")) {
			continue
		}

		exePathLink := fmt.Sprintf("%s/%s/exe", procBase, pidStr)
		exePathResolved, err := os.Readlink(exePathLink)
		if err != nil {
			continue
		}

		cgroupPath := fmt.Sprintf("%s/%s/cgroup", procBase, pidStr)
		cgroupContent, _ := os.ReadFile(cgroupPath)
		inContainer := bytes.Contains(cgroupContent, []byte("docker")) || bytes.Contains(cgroupContent, []byte("kubepods"))

		pidInt, _ := strconv.Atoi(pidStr)

		// If we're inside a DaemonSet, remap the path for host
		if strings.HasPrefix(procBase, "/host") {
			exePathResolved = fmt.Sprintf("/host%s", exePathResolved)
		}

		return pidInt, exePathResolved, inContainer, nil
	}

	return 0, "", false, fmt.Errorf("kube-apiserver process not found")
}

const (
	writeSymbol = "crypto/tls.(*Conn).writeRecordLocked"
	// readSymbol  = "crypto/tls.(*Conn).Read"
	readSymbol  = "crypto/tls.(*Conn).readRecordOrCCS"
)

// Define the symbols to be probed.
var symbols = []SymbolProbe{
	{Name: writeSymbol, UprobeProgram: "GotlsWriteRegister", UprobeExProgram: "GotlsWriteRetRegister"},
	{Name: readSymbol, UprobeProgram: "GotlsReadRegister", UprobeExProgram: "GotlsReadRetRegister"}, // Re-enabled readSymbol for completeness as it's common
}

// IntArrToByteArr converts an int8 array to a byte slice.
func IntArrToByteArr(Data [17408]int8, DataLen int) ([]byte) {
	// Convert event.Data to a []byte
	data := make([]byte, DataLen)
	for i := 0; i < DataLen; i++ {
		data[i] = byte(Data[i]) // Cast int8 to byte (uint8)
	}
	return data
}

var (
	hubHost = flag.String("hub_host", "localhost", "Hostname or IP of the hub server")
	hubPort = flag.Int("hub_port", 50051, "Port of the hub server")
)

func main() {
	// Parse command line flags.
	flag.Parse()

	// Find kubernetes API server path
	_, binPath, _, err := findKubeAPIServer()
	if(err != nil){
		log.Fatalf("Failed to find kube-apiserver: %v", err)
	}

	// Attach UPROBEs and KPROBEs.
	// `links` will hold references to the attached eBPF links.
	var links []link.Link

	// Setup OS signal handling for graceful shutdown.
	ctx, cancel := context.WithCancel(context.Background())
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, os.Interrupt, syscall.SIGTERM)

	// Goroutine to handle OS signals and cancel the context.
	go func() {
		<-sigs
		fmt.Println("Received interrupt, shutting down...")
		for e, link := range links {
			if err := link.Unpin(); err != nil {
				log.Printf("Failed to unpin link %d: %v", e, err)
			}
		}
		cancel() // Signal all blocking operations and loops to exit.
	}()

	// Allow the current process to lock memory for eBPF resources (maps, programs).
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Failed to remove memlock limit: %v", err)
	}

	// Load pre-compiled eBPF programs and maps into the kernel.
	// `uprobeObjects` is typically generated by bpf2go.
	objs := uprobeObjects{}
	if err := loadUprobeObjects(&objs, nil); err != nil {
		log.Fatalf("Failed to load eBPF objects: %v", err)
	}
	// Ensure eBPF objects (programs and maps) are closed when main exits.
	defer objs.Close()

	objs.GlobalOrderCounter.Update(uint32(0), uint64(time.Now().UnixNano()), ebpf.MapUpdateFlags(ebpf.UpdateAny))

	// Open the target executable for UPROBE attachment.
	ex, err := link.OpenExecutable(binPath)
	if err != nil {
		log.Fatalf("Failed to open executable %s: %v", binPath, err)
	}

	// Attach Go TLS UPROBEs and URETPROBEs.
	// The `AddGoTlsLinks` function (assumed to be defined elsewhere)
	// should iterate through `symbols` and attach the respective probes.
	links = append(links, AddGoTlsLinks(ex, objs, symbols, binPath)...)

	// Attach TCP/syscall KPROBEs.
	// `AddTCPLinks` and `AddSyscallLinks` (assumed to be defined elsewhere)
	// should attach kernel probes for network and syscall events.
	links = append(links, AddTCPLinks(objs)...)
	links = append(links, AddSyscallLinks(objs)...)

	for e, link := range links {
		link.Pin("/sys/fs/bpf/uprobe_test/link" + fmt.Sprint(e))
	}

	// Create a new reader for the ring buffer map `objs.Events`.
	// rd, err := ringbuf.NewReader(objs.Events)
	rd, err := perf.NewReader(objs.Events, 17*4096)
	if err != nil {
		log.Fatalf("Failed to create ringbuf reader: %v", err)
	}
	// Ensure the ring buffer reader is closed when main exits.
	defer rd.Close()

	// Establish gRPC connection to the traffic collector service.
	conn, err := grpc.NewClient(*hubHost+":"+strconv.Itoa(*hubPort), grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to gRPC server: %v", err)
	}
	// Ensure the gRPC connection is closed when main exits.
	defer conn.Close()

	client := NewTrafficCollectorClient(conn)

	// Open a gRPC stream for sending events.
	stream, err := client.StreamEvents(ctx)
	if err != nil {
		log.Printf("Failed to open gRPC event stream, continuing without gRPC: %v", err)
		stream = nil // Set stream to nil to skip sending events
	}

	// Synchronous event processing loop.
	// This loop will directly read from the ring buffer and process events.

	event := uprobeGoTlsEvent{}                     // Reuse event struct to minimize allocations
	// record := ringbuf.Record{} // Reuse record struct for reading from the ring buffer
	record := perf.Record{} // Use perf.Record for reading from the perf reader

	log.Println("Starting synchronous eBPF event processing...")
	for {
		// Check if the context has been cancelled (e.g., by signal handler).
		select {
		case <-ctx.Done():
			log.Println("[Main Loop] Context canceled, shutting down event processing.")
			return // Exit the main function.
		default:
			// Continue with reading.
		}

		// It will block until an event is available or the deadline times out.
		rd.SetDeadline(time.Now().Add(time.Second * 5)) // Set a 5-second timeout for ReadInto
		// Read a record from the kernel ring buffer.
		// This call will block until a record is available or the deadline expires.
		err := rd.ReadInto(&record) // Assuming uprobeGoTlsEvent has a RawSample field for direct read
		if err != nil {
			// Handle specific errors from ringbuf.Reader.
			if err == ringbuf.ErrClosed {
				log.Println("[Main Loop] Ring buffer reader closed. Exiting.")
				return // Exit if the reader is explicitly closed.
			}
			if os.IsTimeout(err) {
				// This is expected if there are no events within the deadline.
				// We just log it and continue looping to check ctx.Done().
				log.Printf("[Main Loop] No event received within deadline (timeout): %v", err)
				rd.SetDeadline(time.Now().Add(time.Second * 5)) // Reset deadline for next read
				continue
			}

			if(err == io.EOF){
				continue // EOF is expected when the reader is closed, just skip to next iteration
			}

			// For any other unexpected error, log it and attempt to continue.
			log.Printf("[Main Loop] Failed to receive event: %v (continuing)", err)

			// rd.SetDeadline(time.Now().Add(time.Second * 5)) // Reset deadline
			// time.Sleep(100 * time.Millisecond)             // Small pause to prevent tight loop on persistent errors

			continue
		}

		// Process the received event synchronously.
		// (Assuming uprobeGoTlsEvent also includes the necessary fields for binary.Read)
		if err := binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event); err != nil {
			log.Printf("[Main Loop] Failed to decode event: %v", err)
			continue
		}

		// Call your existing event processing logic.
		processEvent(event, stream)

		// // Reset deadline for the next read to prevent immediate timeout after an event.
		// rd.SetDeadline(time.Now().Add(time.Second * 5))
	}

	// This part of main() is unreachable if the loop exits via 'return'.
	// It's usually here to wait for goroutines, but in a synchronous model, it's less relevant.
	// The signal handling goroutine implicitly causes main to exit by canceling context.
	
	//fmt.Println("Shutdown complete (should not be reached if loop exits via return).")
}

// processEvent handles a decoded event, sends to gRPC stream, prints info.
// (This function remains unchanged from your original code)
func processEvent(event uprobeGoTlsEvent, stream TrafficCollector_StreamEventsClient) {
	const (
		AF_INET  = 2
		AF_INET6 = 10
	)

	var srcIP, destIP, addressFamily string
	switch event.AddressInfo.Family {
	case AF_INET:
		srcIP = uint32ToIP(event.AddressInfo.Saddr4).String()
		destIP = uint32ToIP(event.AddressInfo.Daddr4).String()
		addressFamily = "AF_INET"
	case AF_INET6:
		srcIP = net.IP(event.AddressInfo.Saddr6[:]).String()
		destIP = net.IP(event.AddressInfo.Daddr6[:]).String()
		addressFamily = "AF_INET6"
	}

	srcPort := ntohs(event.AddressInfo.Sport)
	destPort := ntohs(event.AddressInfo.Dport)

	// if destIP != "192.168.100.1" && destIP != "1.100.168.192" {
	// 	return
	// }

	fmt.Println("<=========================================================================================>")
	fmt.Printf("Event from PID %d: %s\n", event.Pid, int8ArrayToString(event.Comm[:]))
	fmt.Printf("Event ID: %d\n", event.Goid)
	fmt.Printf("Order: %d\n", event.OrderIndex)
	fmt.Printf("File Descriptor: %d\n", event.Fd)
	fmt.Printf("Address Info: %s, %s : %d -> %s : %d\n", addressFamily, srcIP, srcPort, destIP, destPort)

	if event.DataLen < 0 || event.DataLen > int32(len(event.Data)) {
		log.Printf("Warning: DataLen out of bounds: %d", event.DataLen)
		event.DataLen = int32(len(event.Data))
	}

	byteData := unsafe.Slice((*byte)(unsafe.Pointer(&event.Data[0])), event.DataLen)

	fmt.Printf("Data Len: %d\n", event.DataLen)
	fmt.Printf("Data: %s\n\n", hex.EncodeToString(byteData))

	hostname, err := os.Hostname()
	if err != nil {
		hostname = ""
	}

	if(stream!=nil){
		stream.Send(&GoTlsEvent{
			Goid:        event.Goid,
			Pid:         event.Pid,
			Tid:         event.Tid,
			Fd:          event.Fd,
			Data:        IntArrToByteArr(event.Data, int(event.DataLen)),
			DataLen:     event.DataLen,
			TsNs:        event.TsNs,
			EventType:   uint32(event.EventType),
			Node:        hostname,
			Comm:        int8ArrayToString(event.Comm[:]),
			AddressInfo: &UprobeAddressInfo{
				Family: event.AddressInfo.Family,
				Saddr4: event.AddressInfo.Saddr4,
				Daddr4: event.AddressInfo.Daddr4,
				Sport:  uint32(event.AddressInfo.Sport),
				Dport:  uint32(event.AddressInfo.Dport),
				Saddr6: event.AddressInfo.Saddr6[:],
				Daddr6: event.AddressInfo.Daddr6[:],
			},
		})
	}

	fmt.Println("<=========================================================================================>")
}