package main

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"fmt"

	"log"
	"net"
	"os"
	"os/signal"
	"time"
	"unsafe"

	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/perf"
	"github.com/cilium/ebpf/rlimit"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/hpack"
)

const (
	//binPath = "/root/ebpf/uprobe-test/http2-dec/http2-dec"
	binPath = "/usr/local/bin/kube-apiserver"
	//binPath = "/root/ebpf/tlswrite-example/tlswrite-example"
	writeSymbol  = "crypto/tls.(*Conn).writeRecordLocked"
	readSymbol = "crypto/tls.(*Conn).Read"
	http2Symbol = "golang.org/x/net/http2.(*Framer).ReadFrame"
)

func main() {
	stopper := make(chan os.Signal, 1)
	signal.Notify(stopper, os.Interrupt, syscall.SIGTERM)

	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatal(err)
	}

	// Load pre-compiled programs and maps into the kernel.
	objs := uprobeObjects{}
	if err := loadUprobeObjects(&objs, nil); err != nil {
		log.Fatalf("loading objects: %s", err)
	}
	defer objs.Close()

	// Open an ELF binary and read its symbols.
	ex, err := link.OpenExecutable(binPath)
	if err != nil {
		log.Fatalf("opening executable: %s", err)
	}

	// Open a Uprobe at the exit point of the symbol and attach
	// the pre-compiled eBPF program to it.
	// Try getting the address of our symbol from GoReSym
	writeSymVA, writeSymOffset, writeSymExits ,err:= GetOffsets(binPath, writeSymbol);
	fmt.Printf("%d, %d\n", writeSymOffset, writeSymExits[0]);
	if err!=nil {
		fmt.Println(err.Error())
	}
	fmt.Printf("Found address of symbol (%s): %d\n", writeSymbol, writeSymVA)
	fmt.Printf("Calculated file offset of symbol at address (%d), %d\n", writeSymVA, writeSymOffset)


	writeUprobe, err := ex.Uprobe(writeSymbol, objs.GotlsWriteRegister, &link.UprobeOptions{Offset: 0x00, Address: writeSymOffset})
	if err != nil {
		log.Fatalf("creating uprobe: %s", err)
	}
	defer writeUprobe.Close()

	var links []link.Link // Store all attached probes
	for _, exit := range writeSymExits {
		l, err := ex.Uprobe(writeSymbol, objs.GotlsWriteRetRegister, &link.UprobeOptions{Offset: 0x00, Address: exit})
		if err != nil {
			log.Fatalf("failed to attach uprobe: %v", err)
		}
		links = append(links, l)
	}

	readSymVA, readSymOffset, readSymExits ,err:= GetOffsets(binPath, readSymbol);
	fmt.Printf("%d, %d\n", readSymOffset, readSymExits[0]);
	if err!=nil {
		log.Fatalf("Failed to get offsets %v ", err)
	}
	fmt.Printf("Found address of symbol (%s): %d\n", readSymbol, readSymVA)
	fmt.Printf("Calculated file offset of symbol at address (%d), %d\n", readSymVA, readSymOffset)

	// 
	readUprobe, err := ex.Uprobe(readSymbol, objs.GotlsReadRegister, &link.UprobeOptions{Offset: 0x00, Address: readSymOffset})
	if err != nil {
		log.Fatalf("creating uprobe: %s", err)
	}
	defer readUprobe.Close()

	for _, exit := range readSymExits {
		l, err := ex.Uprobe(readSymbol, objs.GotlsReadRetRegister, &link.UprobeOptions{Offset: 0x00, Address: exit})
		if err != nil {
			log.Fatalf("failed to attach uprobe: %v", err)
		}
		links = append(links, l)
	}

	tcpSendmsg, err := link.Kprobe("tcp_sendmsg", objs.TcpSendmsg, nil)
	if err != nil {
		log.Fatalf("failed to attach kprobe: %v", err)
	}
	links = append(links, tcpSendmsg)
	defer tcpSendmsg.Close()

	tcpCleanupRbuf, err := link.Kprobe("tcp_cleanup_rbuf", objs.TcpCleanupRbuf, nil)
	if err != nil {
		log.Fatalf("failed to attach kprobe: %v", err)
	}
	links = append(links, tcpCleanupRbuf)
	defer tcpCleanupRbuf.Close()

	// Links for fd probes
	sys_enter_read, err := link.Tracepoint("syscalls", "sys_enter_read", objs.SysEnterRead, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_enter_read)
	defer sys_enter_read.Close()

	sys_enter_write, err := link.Tracepoint("syscalls", "sys_enter_write", objs.SysEnterWrite, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_enter_write)
	defer sys_enter_write.Close()

	sys_enter_recvfrom, err := link.Tracepoint("syscalls", "sys_enter_recvfrom", objs.SysEnterRecvfrom, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_enter_recvfrom)
	defer sys_enter_recvfrom.Close()

	sys_enter_sendto, err := link.Tracepoint("syscalls", "sys_enter_sendto", objs.SysEnterSendto, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_enter_sendto)
	defer sys_enter_sendto.Close()

	sys_exit_read, err := link.Tracepoint("syscalls", "sys_exit_read", objs.SysExitRead, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_exit_read)
	defer sys_exit_read.Close()

	sys_exit_write, err := link.Tracepoint("syscalls", "sys_exit_write", objs.SysExitWrite, nil); 
	if err != nil {
		log.Fatalf("failed to attach tracepoint: %v", err)
	}
	links = append(links, sys_exit_write)
	defer sys_exit_write.Close()

	// Open a perf event reader from userspace on the PERF_EVENT_ARRAY map
	// described in the eBPF C program.
	rd, err := perf.NewReader(objs.Events, 4096*50)
	if err != nil {
		log.Fatalf("creating perf event reader: %s", err)
	 }
	 defer rd.Close()

	// Periodically fetch the packet counter from PktCount,
    // exit the program when interrupted.
    stop := make(chan os.Signal, 5)
    signal.Notify(stop, os.Interrupt)

	// Read values in a loop
	var record perf.Record
	var buffer bytes.Buffer;
	framer := http2.NewFramer(nil, &buffer)
	decoder := hpack.NewDecoder(4096, nil) // 4096 is the dynamic table size
	lastHeaders := make(map[uint64][]byte)
	for {
		select {
		case <-stop:
			fmt.Println("Exiting...")
			// Later, when cleaning up:
			for _, l := range links {
				l.Close() // Detach and clean up the uprobe
			}
			return
		default:
			fmt.Printf("<=========================================================================================>\n")
			var event uprobeGoTlsEvent
			
			rd.SetDeadline(time.Now().Add(time.Second*5))
			err := rd.ReadInto(&record)
			if err != nil || len(record.RawSample) == 0 {
				fmt.Printf("Err: %s\n", err)
				continue
			}

			err = binary.Read(bytes.NewReader(record.RawSample), binary.LittleEndian, &event)
			if err != nil {
				fmt.Printf("Failed to decode event: %v, event: %s\n", err, hex.EncodeToString(record.RawSample))
				continue
			}

			const AF_INET int = 2; 
			const AF_INET6 int = 10;
			const GOTLS_EVENT_TYPE_WRITE = 0;

			var srcIp string;
			var destIp string;
			var address_family string;
			if(event.AddressInfo.Family == uint32(AF_INET)){
				srcIp = 	uint32ToIP(event.AddressInfo.Saddr4).String();
				destIp =	uint32ToIP(event.AddressInfo.Daddr4).String();
				address_family = "AF_INET"
			}else if(event.AddressInfo.Family == uint32(AF_INET6)){
				srcIp = 	net.IP(event.AddressInfo.Saddr6[:]).String();
				destIp =	net.IP(event.AddressInfo.Daddr6[:]).String();
				address_family = "AF_INET6"
			}

			srcPort :=  ntohs(event.AddressInfo.Sport);
			destPort := ntohs(event.AddressInfo.Dport);

			if (destIp != "192.168.100.1" && destIp != "1.100.168.192"){
				continue
			}

			fmt.Printf("\n\nEvent from PID %d: %s\n", event.Pid, int8ArrayToString(event.Comm[:]))
			fmt.Printf("Event ID: %d\n", event.Id);
			fmt.Printf("File Descriptor: %d\n", event.Fd)
			if(event.EventType == GOTLS_EVENT_TYPE_WRITE){
				fmt.Printf("Address Info: %s, %s : %d -> %s : %d\n", address_family, srcIp, srcPort, destIp, destPort);
			}else{
				fmt.Printf("Address Info: %s, %s : %d -> %s : %d\n", address_family, destIp, destPort, srcIp, srcPort);
			}

			if event.DataLen < 0 || event.DataLen > int32(len(event.Data)) {
				fmt.Printf("Warning: DataLen out of bounds: %d (max: %d)\n", event.DataLen, len(event.Data))
				event.DataLen = int32(len(event.Data)) // Cap it at max size to prevent crash
			}
			// String
			data := int8ArrayToString(event.Data[:event.DataLen])
			// Zero-copy conversion using unsafe
			byteData := unsafe.Slice((*byte)(unsafe.Pointer(&event.Data[0])), event.DataLen)

			// Print hex
			_ =  hex.EncodeToString(byteData)

			// Print ascii
			fmt.Printf("Data Len: %d\n", event.DataLen)
			_ = data
			//fmt.Printf("Data: %s\n\n\n", data)
			fmt.Printf("Data: %s\n\n", hex.EncodeToString(byteData))

			// Decode and print the http2 frames (if any)
			decodeHttp2(byteData, framer, decoder,&lastHeaders,event.Id, &buffer)

			fmt.Printf("<=========================================================================================>\n")
		}
	}
}